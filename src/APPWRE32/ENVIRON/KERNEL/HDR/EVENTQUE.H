/*//////////////////////////////////////////////////////////////
//
//											Copyright 1993, Novell, Inc.
//
//		<standard disclaimers here>
//
//
//--------------------------------------------------------------
//
// FILE:
//
// AUTHOR:
//
// DESCRIPTION:
//
// CHANGES:
//
//	7/22/93		Scott
//		Removed FetchOSEvents() & TranslateAndPush() since we are no longer
//		putting Windows messages on the Serius queue.
//
//////////////////////////////////////////////////////////////*/


/*[ EVENTQUE.H ]======================================================*\
|
|  The event queue is a regular queue with an additional insertion
|  point called the mark.  Serius events that are posted with the
|  'how' field set to AEVT_ATMARK are placed into the queue at the mark
|  insertion point. All other insertions happen at the tail of the
|  queue.
|
|  Conceptually, the mark is the tail of a high-priority event queue
|  that must be emptied before the next event in the main event queue
|  is processed.
|
\*====================================================================*/

#ifndef _EVENTQUEUE_H
#define _EVENTQUEUE_H

  #include <setjmp.h>

  #include "eventqnd.h"
  #include "eventqms.h"
  #include "markstac.h"
  #include "uidstack.h"

  class   EXEEVENTLIST;
  typedef EXEEVENTLIST  * LPEXEEVENTLIST;

  class   EXEFUNCINST;
  typedef EXEFUNCINST  * LPEXEFUNCINST;

  class   EXEFLOWMGR;
  typedef EXEFLOWMGR  * LPEXEFLOWMGR;

class EVENTQUEUE
  {

private:

  LPEVENTQUEUENODE  head;  // points to next event to be popped
  LPEVENTQUEUENODE  mark;  // the current high priority insertion point
  LPEVENTQUEUENODE  tail;  // points to the lowest priority event in queue

  LPEXEEVENTLIST    eventList;       // the eventList for this task
  UIDSTACK          functionStack;   // the currently executing function

  // some flags
  BOOL              isOpen;      // Events are refused if the queue has been closed
  BOOL              isDebugging; // There is at least one Stop set...
	BOOL							doSingleStep;

  LPEVENTQUEUENODE  currentEventNodePtr;
     // ptr to the node most recently popped (ie, in process) so that
     // when we pop the next one we can reclaim memory.  Events that
     // were generated by Windows messages have the raw MSG struct
     // hanging off the event from the details field.

  LPEVENTQUEUENODE  headWaiter;  // head of the wait queue

  MARKSTACK         markStack;
     // Remember all marks for (possibly nested) AEVT_ATONCE events.  Referred
     // to and maintained in KillIf processing (cf).

  jmp_buf  bailOut;
  BOOL     gotBailOut;

 //-- Pop'd event handlers (plus the public member CallMethod) --//
  BOOL  HandleSignal      (pAEvtInfo theEvent);
  BOOL  CallFunction      (pAEvtInfo theEvent);

  BOOL  KillIf (
    LPEVENTQUEUENODE  hitMan,
    LPEVENTQUEUENODE   & qHead);
    // General purpose kill processor.  Compares properties of all
    // nodes on the specified queue to the hitMan node and eliminates
    // all of those that meet the specs of hitMan->how.

  BOOL  FollowFlow(
    LPEXEFLOWMGR theFlowSource,
    LONG         theFlowIdx,
    AOBJECTID     theTargetObject);
    // Posts a 'callFunction' event for each function that is connected
    // to theFlowIdx for theFlowSource.

  void AugmentInputInfo(
    LONG  * theInfo,
	  WORD       theVKey,
    LONG       theIsFlag);

  LONG UpdateLastDownInfo(
    LPMSG currentMsg);

  LONG UpdateLastUpInfo(
	  LPMSG currentMsg);

  BOOL MakeTheCall(
	  METHODPROC     theRoutine,
	  pAEvtInfo theEvent,
	  pAObjMessage      theSystem);


public:

  EVENTQUEUE();

  ~EVENTQUEUE();

  void            SetEventList (LPEXEEVENTLIST theList)
    {
    eventList = theList;
    }

  LPEXEEVENTLIST  GetEventList ()
    {
    return eventList;
    }

  LPEXEFUNCINST   GetCurrFunc()
    {
    return (LPEXEFUNCINST)functionStack.GetTop().ptr;
    }

  BOOL  Push (pAEvtInfo newEvent, LONG flags=0L);
    // Inserts newEvent onto the queue.  Flags are for the shell's
    // use only.

  pAEvtInfo Pop ();
    // Removes and returns the event at the head of the event queue.

  LPEVENTQUEUENODE  GetHead()
    {
    return head;
    }

  AEvtInfo*		WaitQueueHead(void);

  BOOL  HandleEvent(pAEvtInfo theEvent);
    // Processes the event pointed to.

  BOOL  CheckForMethod(ATYPEID theType, AEVENTID selector);
    // See if the specified type supports the specified event.

  BOOL  CallMethod(pAEvtInfo theEvent, ATYPEID theType);

 // queue status functions
  BOOL   IsOpen()
    {
    return isOpen;
    }

  void   Open  ()
    {
    isOpen = TRUE;
    }

  void   Close ()
    {
    isOpen = FALSE;
    }

 // debug mode status functions
  void  SetIsDebugging (BOOL yesOrNo)
    {
    isDebugging = yesOrNo;
    }

  void SetBailOut(
    jmp_buf  *jumper)
    {
    CopyMemory(bailOut, *jumper, sizeof(*jumper));
    gotBailOut = TRUE;
    }

  BOOL GotBailOut()
    {
    return gotBailOut;
    }

	void SetSingleStepFlag()
		{
		doSingleStep = TRUE;
		}

	void ClearSingleStepFlag()
		{
		doSingleStep = FALSE;
		}

	BOOL TestSingleStepFlag()
		{
		return doSingleStep;
		}
  };

typedef EVENTQUEUE  * LPEVENTQUEUE;

#endif  // _EVENTQUEUE_H
