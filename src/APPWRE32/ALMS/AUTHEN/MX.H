#ifndef MXINCLUDED
#define MXINCLUDED

#ifdef __cplusplus
extern "C" {
#endif

/*
	This file is included by all 'C' files produced by the MX compiler.
	This file contains prototypes and definitions used for the mx
	runtime routines, mx.lib.

	V3.06 12/19/91	Added larger numbers to accomodate larger table sizes
						- Bevan Rowley
	V3.05	4/5/90		Added some error checking to the compiler and the
						library routines, added the mxError error reporting
						system. - Dale Olds
	V3.04	3/30/90		reintegrated original C source in the library,
						converted to ANSI C with prototypes, type casts on
						all table members produced by the compiler - Dale Olds
	V3.03	1 Jan 90	Modified to accept characters in variable
						strings in the range on 128-255. - Dale Olds
	V3.02	4 Mar 89	Slight modifications for Turbo C v2.0.
						Also changed some formatting, added "\nError: "
						to begin error messages, "\n" to end, set
						exit codes so that MX could be used by MAKE
						more effectively.   - Dale Olds
	V3.00	08/09/84
	V2.03	12/09/82	by Mark Hurst

	Copyright (C) 1982, 1983, 1984 by Mark Hurst
	All Rights Reserved.
*/

/*-----------------------------------------------------------------------------
 * constants
 */
#define MAXTOKENLEN	50	/* maximum chars in a name */
#define MAXLEX		100	/* maximum allowable tokens in line */

/*
 * when Parse() or AddToken() fails mxError
 * is set to one of these values. AddToken() may set
 * MX_NOMEMORY, MX_TOKENTOOLONG or MX_TOKENTABLEFULL.
 * Parse() may set any of them except MX_TOKENTOOLONG
 * or MX_TOKENTABLEFULL.
 */
enum ERRORCODES
{
	MX_NOERROR, MX_NOPARSE, MX_NOMEMORY, MX_TOKENTOOLONG, MX_TOKENTABLEFULL,
	MX_TOOMANYTOKENS, MX_BADTOKENTABLE, MX_ERRORDIRECTIVE, MX_ABORTDIRECTIVE,
	MX_INTERNALERROR
};


enum SPECIALTOKENS
{
	VARIABLE = 2000, ACCEPT_TOKEN, NULL_TOKEN, EOL, UNKNOWN_TOKEN,
	ACTION, EOD, ERROR_TOKEN, BACKUP_TOKEN
};

#define FIRST_TERMINAL 1001
 
/*-----------------------------------------------------------------------------
 * common structure definitions, used by the library and 'C' files
 * produced by the preprocessor
 */

typedef struct MATCH
{
	unsigned int id, value;
	struct MATCH *link;
} MATCH;

typedef	struct TOKENTABLENODE
{
	struct TOKENTABLENODE *son, *brother;
	MATCH *match;
	unsigned char character;
} TOKENTABLENODE;

typedef	struct TOKENTABLELIST
{
	unsigned int son, brother;
	unsigned int match;
	unsigned char character;
} TOKENTABLELIST;

/*
 * vCount is set to be the max tokens for a line
 * As  as I can figure out, the 'value' field has the following format:
 *   value[0] ... value[vCount - 1]: value of the corresponding token,
 *                                   see MVal(), TVal(), etc.
 *   value[vCount] ... value[2*vCount - 1]: locTokenIndex of the corresponding
 *                                   token, see TLoc(), TChP(), etc.
 *   value[2*vCount] ... value[3*vCount - 1]: tokenIndex of the corresponding
 *                                   token, see Parse(), ReplaceToken().
 *   value[3*vCount]: overflow area, it must be there or the heap is corrupted.
 *   															-- DRO
 */
typedef struct PARSENODE
{
	struct PARSENODE *link;
	WORD *def;
	WORD locIndex, locTokenIndex, startingTokenIndex;
	WORD tokenIndex, vCount, masterSet, masterValue;
	WORD value[1]; /* variable length array */
} PARSENODE;

typedef struct LEXER
{
	WORD varParsed, rIndex, index, filler;
	unsigned int avail;
} LEXER;

typedef struct mxglobs
{
	unsigned int maxTokens, tokenCount, mxError;
	WORD unkRetIndex, tokenStart, eOLRetIndex, unknownReturned, eOLReturned;
	WORD currentIndex, listCount, index;
	BYTE *line;
	WORD freeSpace[2000], *mxList[200];
	unsigned int avail;
	PARSENODE *lpc, *pc; /* pointer to current work state */
	LEXER lState[MAXLEX];
	TOKENTABLENODE *theTokenTable, *tTreeStart;
	MATCH *matchTable;
	int tTreeSize, matchTSize;
	unsigned int  *pSession;
} MXGLOBALS;



/*-----------------------------------------------------------------------------
 * these variables are in the *tt.c module produced by the preprocessor
 */
extern unsigned int  *nonTerminals[];
extern unsigned char *varAddressTable[];

/*-----------------------------------------------------------------------------
 * Prototypes of routines generated by the MX Processor
 */
extern int ActionProcedure(int action,void *globals);
extern void MXglobalsInit(MXGLOBALS *mxg);
extern void MXglobalsFree(MXGLOBALS *mxg);

/*-----------------------------------------------------------------------------
 * Prototypes of public routines provided by the MX Library
 */
extern int AddToken(MXGLOBALS *mxg,char *text, unsigned char len, unsigned int id, unsigned int value);
extern void DefineTokenTable(MXGLOBALS *mxg,unsigned int, unsigned int);
extern int MVal(MXGLOBALS *mxg);
extern int Parse(MXGLOBALS *mxg,void *globals);
extern char *SChP(MXGLOBALS *mxg);
extern void SetMVal(MXGLOBALS *mxg,int);
extern void SetParseAddress(MXGLOBALS *mxg,char *);
extern void SkipVariableToken(MXGLOBALS *mxg,int count);
extern int SLoc(MXGLOBALS *mxg);
extern char *TChP(MXGLOBALS *mxg,int);
extern int TLoc(MXGLOBALS *mxg,int);
extern int TVal(MXGLOBALS *mxg,int);

#ifdef __cplusplus
}
#endif

#endif
