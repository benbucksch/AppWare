10/ 7/93

----------------
OVERVIEW

The Shape library API is a means of formalizing the creation and
manipulation of shapes by the window layout.  Shapes differ from
normal window items in:  1) they aren't connected to a real object;
2) they display some kind of user-interface to get created; and 3)
they let the window object store all of their data.  For normal
operations (i.e., most of the methods in WIP), they are identical to
other window items.

The data within a Window Item (WI) instance of a shape is as follows:
the WI is marked as being a shape; the shape responds to the
GetExtraData() method; and the TYPEID (see next paragraph) is stored
in the m_oiObject field.

Shapes are maintained by a shape library.  Shape libraries are
identified by a TYPEID that is unique across all shape libraries (it
might be necessary in the future to be unique across all types, but
currently this is not the case).  A shape library is contained within
a DLL.  The shape library DLL are specified in an .INI file entry
(except for the required standard library that ships with AppWare:
this will be done by hardcoding a library name most likely).  The DLL
can contain only (currently) one shape library.  Each shape library
DLL has one known procedure that is exported:  SHAPELIBADMIN.  It is
prototyped as

	LONG _far _pascal ShapeLibAdmin(UINT nMsg, AObjMessage* pMsg);

It is responsible for accepting messages from the user of the shape
library (typically the window layout).

Usually a shape library maintains a palette of shapes to choose from.
If this is indeed the case, then the admin procedure will be used to
create, show, hide, move, etc., that palette.  The window layout
makes no assumptions about the palette (other than it responds to the
set of defined messages).  

The window layout exports a number of Standard Tools.  Most of these
tools are modes that are on in the same "operation space" as tools on
a palette that insert shapes.  These are exported for the purpose of
incorporating their images within a shape palette, as well as being
able to set operation modes to them.  The tools that are not equal to
the shape insert mode are typically dialogs, or one-time actions
(e.g., changing the window background).

Communication from the shape library back to the window layout is
done via a layout admin proc similar to the shape lib admin.  The
admin proc address is passed to the shape library in the
OSHP_SETLAYOUTINFO message.

An important notion for the window layout is the "active tool."  The
active tool is the one that is given messages such as mouse down,
move move, mouse up, etc.  The Shape API allows setting of the
current tool.  If the current tool set is a non-standard tool, the
attributes of the shape library are queried when these
events/messages occur (e.g., if a mouse down occurs when the
"Metafile" shape library is active, then its capabilities are
queried).

The capabilities of the shape library are better described as the
attributes of the library.  They tell things such as:  a palette is
maintained by the library; the Create Function should be called on
mouse down (versus mouse up); etc.


----------------
DETAILS

The messages to the admin procedure can be broken down as follows:

* General information queries.  These messages are sent to the
library before any other messages are sent.  The order is not defined.

OSHP_SETLAYOUTINFO
	The layout handle is passed in pMsg->message1 and message2 is the
	admin proc function address.  The layout handle must be passed back
	to the layout for all OSHP_MSG_* messages back to the layout.

OSHP_QUERYLIBINFO
	This should return the pointer to the create function (see
	WIP for more information) in pMsg->message1.  The TYPEID of the
	library should be returned in message2, and the capabilities of the
	library should be returned in message3 (OSHP_LIBCAP_*).  A_OK should be
	returned from the admin procedure if successful.

OSHP_MENUSTRING
	This should copy a string to be used in the menu to the
	buffer pointed to by pMsg->message1 cast to char*.  The 
	length of the buffer is given in pMsg->message2.  The
	contents of the string will be different for shape libraries
	with palettes versus shape libraries that don't have
	palettes.  A_OK should be returned if characters are copied
	to the string.

* Non-palette messages

OSHP_QUERYTOOLINFO
	The capabilities of the tool with id (short) pMsg->message1 should
	be returned in .message2.  The tool's HCURSOR should be returned
	in .message3 (the Layout will not destroy the cursor).  A_OK should 
	be returned if successful.

OSHP_GETSHAPENAME
	This message is sent to all shape libraries.  The shape's
	item pointer is passed in pMsg->message1.  The pointer to the
	buffer to copy the name to is passed in pMsg->message2 cast
	to char*, and the length of the buffer is in pMsg->message3.
	The name of the shape should be copied to the given buffer.
	A_OK should be returned if any characters are copied to the
	buffer. 

OSHP_QUERYVERSIONANDID
  This message is sent to shape libraries when a shape is going to
  be UPSF exported.  pMsg->message1 will contain a pointer to the shape
  window item that is being queried.  The shape library's version (a
  short) will be returned in .message2.  The current shape's type or
  id will be returned in .message3.  A_OK should be returned if the
  query is successful.
  


* Palette manipulation, etc.  For every message (except
	CREATEPALETTE) the palette handle is passed in message1.

OSHP_CREATEPALETTE
	The shape library should create a palette and return a handle
	to it in pMsg->message1.  The owning window (if any) is in .message2
	cast to HWND.  The palette should NOT be shown,
	and no assumptions should be made about where it is
	displayed, when it is displayed, etc.  It should set the
	default tool at this time (??? should it notify the system when
	it does so???).  If the palette cannot be created, then
	A_ERROR should be returned from the admin proc.

OSHP_DESTROYPALETTE
	The palette handle is passed via pMsg->message1.  The palette
	should be destroyed at this time, and all resources freed.
	A_ERROR should be returned if the palette cannot be deleted
	(??? shared palettes???)

OSHP_SHOWPALETTE
	The palette handle is passed via pMsg->message1.  The palette
	should be shown.  If it is to be activated (i.e., it should
	receive focus), then pMsg->message2 will be non-zero, else it
	will be 0.  A_OK should be returned if successful.  It should
	be shown on top of other windows even though it might
	not be activated.

OSHP_ENABLEPALETTE
	The palette handle is passed via pMsg->message1.  The palette
	should be enabled or disabled (ignore activation) according to
	.message2 (TRUE => enabled, FALSE => disable).

OSHP_HIDEPALETTE
	The palette handle is passed via pMsg->message1.  The palette
	should be hidden.  A_OK should be returned if successful.

OSHP_SETPALETTEPOS
	The palette handle is passed via pMsg->message1.  The palette
	should be moved to the screen location given in (->left,->top)
	in the rectangle pointed to by message2.  The palette should
	maintain its hidden or visible state.  A_OK should be
	returned if successful. 

OSHP_GETPALETTEPOS
	The palette handle is passed via pMsg->message1.  The palette's
	screen rectangle should be returned in the rectangle pointed
	to by message2.  A_OK should be returned if successful. 


OSHP_GETPALETTESTATUS
	The palette handle is passed via pMsg->message1.  The palette's
	status should be returned in .message2.  The legal bit values
	for the status are given by the OSHP_PS_* defines.  A_OK
	should be returned if the status is valid.
  

* Tool changes

OSHP_SETTOOLSTATE
	This message is sent only to shape libraries that maintain a
	palette.  The palette handle is passed via pMsg->message1,
	the TYPEID for the library whose tool is active is in msg2,
	the tool id whose state is to be affected is passed in
	pMsg->message3 cast to short.  pMsg->message4 contains what to
	do to the tool.  The possibilities are active, inactive,
	enabled, disabled, up, and down.



----------------
THE APIs

The window object (or, more specifically, the window layout of the
window object) will support communication back to it.  The
communication is done via an admin proc that has the same prototype
as the shape library admin proc.  The following messages are
supported by the layout:

*
	OSHP_MSG_SETACTIVETOOL
	.message1 should be the layout handle passed to the library via
	the message OSHP_SETLAYOUTINFO.
	.message2 should be the TYPEID of the library, and 0 if the tool
	is a standard tool
	.message3 should be the tool id to set (>= OSHP_STDTOOL_USERTOOL)
	.message4 should be an HCURSOR to use while in that tool is active.
	 The HCURSOR is NOT destroyed by the layout.

	OSHP_MSG_CREATESHAPE
	.message1 should be the layout handle passed to the library via
	the message OSHP_SETLAYOUTINFO.
	.message2 is the x position of the new shape.  -1 can be specified
	if the layout should use a default position.
	.message3 is the y position of the new shape.  -1 can be specified
	if the layout should use a default position.
	.message4 will be passed to the shape library's create function as
	the extraData parameter.

*
	OSHP_MSG_GETSTDTOOLINFO
	.message1 should be the layout handle passed to the library via
	the message OSHP_SETLAYOUTINFO.
	.message2 is the standard tool id.
	.message3 cast to OShpStdToolInfo* should point to an allocated
	OShpStdToolInfo structure that will be filled in by the layout.

	The fields of the structure are as follows:
			HBITMAP			hImage;
			LONG				lStyle;

	"hImage" is a handle to the bitmap.  The shape library should NOT
	destroy this as the layout owns this bitmap.
	"lStyle" is a combination of the following bits:
		OSHP_STDCAP_TOGGLE		standard tool should behave as a checkbox does
		OSHP_STDCAP_PUSH			standard tool should behave as a checkbox does
		OSHP_STDCAP_RADIO			standard tool should behave as a radio
														button whose group is the palette.
														Palettes have exactly one group of
														radio-button-like tools.