Thompson AWK Documentation Version 2.03a
Copyright 1993 by Thompson Automation, Inc.
All Rights Reserved.
For more information contact: Thompson Automation, Inc;
5616 SW Jefferson;  Portland, OR  97221;
Phone: 503-224-1639;  FAX: 503-224-3230

January 1993.

========================== DOCUMENTATION ================================

The operation of AWK is described in the book:

	"The AWK Programming Language"
	by Aho, Kernighan and Weinberger
	Addison-Wesley Publishing Co., Reading, MA.

Thompson AWK is 100% compatible with this book and will run all examples
in this book, with the exceptions noted at the end of this file.
Additional notes on UNIX compatibility are included at the end of this file.



====================== USING THE Instant-AWK PROGRAM =====================

There are two ways to invoke Thompson AWK.  The easiest way is to use
the Instant-AWK (awk.exe) program, which conveniently compiles one or
more programs using a standard AWK command line and immediately invokes
the compiled program.  Another more complex way is to use the AWK
Compiler (awkc.exe) program, which is a two step process where you
compile your program, then run it.  Using the AWK Compiler allows
you to create combined AWK/C programs, and the AWK Compiler has
more command line options.

The Instant-AWK program is used as documented in the "AWK Programming Language"
except as follows:

    1)  The AWK manual gives numerous examples of simple AWK programs
	entered on the AWK command line like this:

	      awk 'program ...' filenames

	We do not recommend this method under DOS because DOS interprets
	any > or < symbols in the program as program redirections,
	and messes it up.  (The Thompson Toolkit Shell and UNIX systems
	do not have this problem.)  Instead, you can enter awk with
	no arguments, like this:

	      awk

	Then AWK will prompt you for program to run.  The program can
	be multiple lines.  After you enter the program, enter an
	empty line to indicate the end of the program.  Then awk will
	prompt you for the program arguments, which are usually
	filenames to be processed.  Enter the program arguments,
	or just press enter again if there are none.  AWK will then
	compile and run your program on the specified files.
 
    2)  The command line options for Instant-AWK are as follows:
 
	-F"x"
	    Makes x the initial field separator;  The quotes are optional
	    if x is not a space or other special character.
	-v name="value"
	    Sets the AWK program variable: name to the specified value
	    before the AWK program starts.  No spaces are allowed except
	    within the quoted value.  The quotes are optional if the value
	    does not contain any spaces or other special characters.
	    Multiple -v options may be given to change multiple variables.
	    Note: Not all variables can be changed with the -v option.
	    Normally only variables that are declared global can be changed.
	    If there is only one source file, or if the -g option is
	    specified, then undeclared variables can also be changed.
	-f filename
	    Reads the program from file: filename.awk.  If no extension
	    is specified, ".awk" is assumed.  If the filename does not
	    include a path specifier and is not in the current directory,
	    then the filename is searched for in the directories specified
	    by the AWKPATH environment variable, if any.  Multiple -f options
	    may be specified to compile multiple programs together.

    The following options are not part of the AWK standard:

	-eb  This option enables backslash processing extension: see the full
	    description under AWK Compiler options below.
	-g  Makes all undeclared variables global.  This is useful only when
	    two or more AWK program files are compiled simultaneously.
	    This option is useful when a program that contains undeclared
	    variables is broken up into multiple files, so the undeclared
	    variables in the original source file are shared globally among
	    all the new smaller source files.
	-w  Suppresses both compile time and runtime warning messages
	    from the AWK program;
	--  This option causes all option processing to stop.  It is useful
	    to allow an AWK option to be passed as an argument to an AWK
	    program without being interpreted by AWK as an AWK option.
	    For example, to pass "-v" as an argument to an AWK program,
	    so that ARGV[1] will be "-v", you could do this:

	    	awk -f myprog.awk -- -v

	    For backward compatibility, the -- option also causes variable
	    assignments occuring before it on the command line to occur
	    before the BEGIN blocks in the program are executed.  Using
	    the -v option is the newer method, and is recommended
	    for all future AWK programs. The following are equivalent:
	    
	    	awk -f myprog.awk -v name="value"
	    	awk -f myprog.awk name="value" --


========================= USING THE AWK COMPILER ===========================

The Thompson AWK Compiler program is named awkc.exe.  Its syntax is as follows:

	awkc [ -options ] filename ...

The specified filenames are all compiled and linked together into
a single program.  The filenames must have the suffix ".awk".

The AWK Compiler can produce several different types of executable
files, controlled by the -x option:

   Minimized Executable File:
	This is the default option.  The AWK Compiler produces a
	.EXE file that uses the awkr200.exe file as an overlay to make
	the smallest possible .EXE file.  The compiled program must be
	able to find the awkr200.exe file when it runs.  It will
	look in the directory from which it was invoked, along
	the AWKPATH environment variable, and finally along the PATH
	environment variable.
       
   Stand-alone Executable File:
	This is selected by the -xe option.  The AWK Compiler creates
	a stand-alone .EXE file.  It will be much larger than the file
	produced by the Minimized Executable File option, but it will run
	anywhere, anytime.

   Linked Executable or Object Files:
	The AWK Compiler can create an object (.obj) file,
	and optionally call a linker to combine the AWK program
	with object files or libraries written in C (or another
	language using C calling conventions) to create a combined
	exectuable (.exe) file.  This option is selected by the -xo, -xf
	and -xl options, which are discussed in the awkprog.doc file.

In any case, the compiled AWK program processes the following options
on its command line: -F, -w, -v and --.  The affect of these options on
the compiled program is the same as that documented for the Instant-AWK
program.  If you do not want your compiled program to process these
options, you can specify the -eo option when you compile it.
Unrecognized options, or options following --, are passed to the
compiled AWK program in the ARGV array.


AWKC OPTIONS in alphabetic order:

    -c compiler_option
	This option selects the host compiler and linker to be used for
	linking combined AWK/C options.  The compiler_option may be one of:
		b2  Borland or Turbo C version 2
		b3  Borland or Turbo C version 3
		b   Same as b3: Borland C or Turbo C version 3
		m7  Microsoft C Version 7
		m6  Microsoft C Version 6
		m5  Microsoft C Version 5
		    (Note: Libraries to support Microsoft C version 5
		    are not included, but are available on request.)
		m   Same as m6: Microsoft C Version 6 (this is the default)
		z   Zortech C Version 3.
    -eb   (This option is two letters)
	Combatible backslash option: Unfortunately some implementations
	of AWK process back-slashes inside quoted strings using a method
	contrary to the "AWK Programming Language" book.
	The -eb option causes the AWK Compiler to use this alternate method.
	If the -eb option is specified then a back-slash in a quoted string
	is left alone unless it occurs before one of the characters
	that causes it to have a special meaning, for example "\t"
	is a tab character.  Note that this option affects only literal
	strings in the AWK source file(s); it has no affect on strings
	read into the AWK program at runtime, because these do not undergo
	back-slash processing.  For example:
                            normally      with -eb
               string       produces      produces
               ------       --------      --------
               "\z"           "z"          "\z"
               "\\z"          "\z"         "\z"
               "\\\z"         "\z"         "\\z"
               "\\\\z"        "\\z"        "\\z"
               "\t"           "<tab>"      "<tab>"  <tab> means tab character
               "\\t"          "\t"          "\t"
               "\\\t"         "\<tab>"      "\<tab>"
               "\\\\t"        "\\t"         "\\t"
	Note that without -eb the string "\z" would produce a warning
	message from the AWK Compiler, because the backslash is
	unnecessary and is ignored.
    -ee   (This option is two letters)
	Disables filename expansion of filenames in the ARGV array
	of the compiled program.  The filename patterns are left
	in the ARGV array allowing you to do your own filename expansion
	if you so desire.  Note that a compiled AWK program
	still processes filename patterns in each element of the
	ARGV array when it comes time to read and process that filename,
	so this option does not actually disable the use of
	filename patterns in the compiled program, it just makes
	the original filename patterns show up in the ARGV array.
	As usual, if your program changes any element of the ARGV array
	before AWK processes that element as a filename, AWK processes the
	changed ARGV element rather than the original.
    -eo   (This option is two letters)
	Suppresses default command line processing of options by the
	compiled AWK program.  Specifically, the compiled AWK program
	will ignore any -F, -v, -w or -- options in its command line.
	The -eo and -ee options can be combined, for example: -eoe
    -g  Makes all undeclared variables global.  Normally, undeclared
	variables are made local to the file in which they appear,
	so that variables that are accidently left undeclared do not
	affect other AWK source files.  This option is useful when a
	program that contains undeclared variables is broken up into
	multiple files, so the undeclared variables in the original
	source file are shared globally among all the new smaller
	source files.
    -linkopts "options"
	The specified options are passed to the linker.  The default
	link "options" vary depending on the C compiler. For Microsoft C
	the default options are "/SE:200 /NOE /EXEP" (under DOS) or
	"/PM:VIO /SE:200 /NOE /EXEP" (under OS/2.)  If the specified
	options begin with an equal-sign, these options over-ride the
	previous link options.  Otherwise the specifed options add to
	the existing link options.  Multiple -linkopts can be given.
	The quotes around the options are optional if the options
	contain no spaces or other special characters.
	This option is ignored if no linking occurs.
	(See your C linker documentation for explanation
	of linker options.)
    -linkspec linkpath
	Specifies the full executable name of the linker to use,
	for example: -linkspec "D:\c700\binb\link.exe"
	This option is ignored if no linking occurs.
    -linkstack number
	The specified number is the stack size passed to the linker.
	This option is valid ONLY for Microsoft C.  Borland and
	others specify the stack size using a variable in the C program.
    -o filename
	Names the output file; do not include the extension
	in the specified filename.
    -Ot  or  -Os
	Selects optimization for execution time (-Ot) or size of
	executable file (-Os).  Default is -Os, which creates smaller
	executables.  Currently has no effect except with -xe flag,
	in which case the -Os option creates an executable that was
	compressed using the pklite program from PKWare.
    -p path
	This option specifies a path where AWK will search for files in
	addition to any path specified by the AWKPATH environment variable.
    -s  Strict: Generate a warning message for undeclared variables.
    -tletter
	Where letter is a single letter, specifies the target operating
	system.  Letter may be d for DOS, p for protected mode of OS2,
	or b to create a bound dual-mode executable that runs under
	both DOS and OS2.  The default value of this option is -td for
	the DOS version of the AWK Compiler, and -tb for the OS2 version.
	Bound dual-mode executables are larger than DOS or OS2 protected
	mode executables.
	Note: the AWK Compiler is supplied in separate DOS and OS2 versions.
	An error message will be generated if you attempt to specify
	a target executable for which the appropriate version of the AWK
	Compiler is not installed.  If you install both DOS and OS2 versions
	of the AWK Compiler you can also cross-compile, that is, you can
	create DOS executables using the OS2 version of the AWK Compiler,
	and vice-versa.
    -v  Verbose: print each filename as it is compiled.  If the file
	was previously compiled and does not need to be recompiled,
	that fact is also noted.
    -w  Warnings: This option suppresses warning messages.
	Note that the -w option to the AWK compiler suppresses compilation
	warning messages, and the -w option to the compiled program
	suppresses runtime warning messages.
    -xm   (This option is two letters)
	Generates a minimum size ".exe" file.
	This is the default if no -x option is specified and only AWK (.awk)
	files are specified on the command line.
    -xe   (This option is two letters)
	Generates a stand-alone ".exe" file.
    -xl   (This option is two letters)
	Generates a linked .EXE output file.
	This is the default if no -x option is specified and object (.obj)
	or library (.lib) files are specified on the command line.
	See the awkprog.doc file for further documentation.
    -xf   (This option is two letters)
	Fast linked file: like -xl, but runs fast by calling link
	only when necessary.
	See the awkprog.doc file for further documentation.
    -xo   (This option is two letters)
	Ouput is an object file.
	See the awkprog.doc file for further documentation.
    -z  Disables incremental compilation, causing the compiler to recompile
	all source files completely.  This option is equivalent to
	deleting any previously compiled file before running the compiler.
	Specifying this option also makes the -xf option work like -xl.
	After many compilations the resulting compiled file sometimes
	gets a little larger due to memory fragmentation as files that
	are recompiled are first deleted from and then restored into
	new locations in the resulting compiled file.
	This option sometimes makes the resulting compiled file smaller,
	but of course makes compilation slower if there is more
	than one AWK source file.


CONFIG FILE:

The AWK compiler reads options from a configuration file named "awkc.cfg"
before reading them from the command line.  The configuration file
may contain comment lines that begin with # as the first character.
The configuration file is searched for in the current directory,
then in the directory from which awkc.exe was invoked, and finally
along the path specified by the AWKPATH environment variable, if any.
It is possible and common to have two separate different config files for
the DOS and OS2 versions of the AWK Compiler by placing a separate
awkc.cfg in the bin and binp directories.


LONG COMMAND LINES AND RESPONSE FILES:

The AWK compiler is designed to compile many AWK source files
simultaneously.  The AWK Compiler provides two ways to avoid
long command lines:

    1)  Any part of a command line can be placed in an environment variable.
	To use the environment variable in the AWK Compiler command
	line precede it with a dollar ($) character.  For example:
       
	    set AWKCSTUFF=-xo -eoe -omyfile file1.awk
	    awkc -w $AWKCSTUFF file2.awk file3.awk

    2)  Any part of a command line can be placed in a response file.
	Precede the response file name with @ (at character)
	in the AWK Compiler command line.  For example:
       
	    echo file1.awk file2.awk > respfile
	    awkc -eb @respfile file3.awk
	
	To prevent a fatal error if the response file does not exist,
	precede it with @? instead of @.  The response file may contain
	comment lines that begin with # as the first character.


AWKPATH environment variable:

If an AWK source filename is specified without a path and is not found
in the current directory, then AWK will search each of the directories
specified by the AWKPATH environment variable for the source file.
The AWKPATH environment variable is set up like the PATH variable:
if more than one directory is specified they must be separated
by semi-colons.

The AWK Compiler also uses AWKPATH to search for the other files
required for compilation including: awkr???.exe, the overlay files,
and the awk.lib file.


TEMPORARY FILES:

The awkc and awk programs create temporary files in the directory
specified by the TMP environment variable, or in the current directory
if there is no TMP variable.  The name of the temp files are 
"awktmp.NNN", where NNN is a number.

INCREMENTAL COMPILATION:

This discussion applies only if your program consists of more than
one source file.  To decrease compilation time the AWK compiler
recompiles only those files that have changed since the last compilation.
For this purpose it records the timestamps of the source files into
the executable file.  Therefore you must keep the time and date on your
computer correct.  Alternatively you can use the -z option to disable
incremental compilation, or just delete the output file before each
compilation to force all source files to be recompiled.

Some compiler warning messages are only printed once when the source file
is first compiled.  Because incremental compilation normally allows the
compiler to re-compile only the most recently modified source files,
these warning messages may not be printed again until you modify
the source file that caused the warning, delete the output file, or
specify the -z option to force full recompilation.

Some compiler options affect all source files and force a full
recompile when you start or stop using the option.
These options are -g and -eb.

For interest's sake you can specify the -v option, which causes
the compiler to display the names of files that it compiles,
and also the names of those files that were previously compiled
and left unchanged.


==================== VARIABLE DECLARATIONS ========================

To aid the development of large programs, Thompson AWK
allows variable declarations.  There are three classes of
variables: global, module local and function local.

Global variables:

Those variables that are to be shared between source files must
be declared global.  If a variable is declared global in any
source file then that variable is shared by all source files.
The same variable may be declared global in more than one
source file, but only one of the declarations may include
an initialization.  Global variable declarations typically
appear at the top of the source file, although they may appear 
anywhere outside any function or action statement.
Example:

	global start, finish = 3, linecount;

This declares the variables start, finish, and linecount as global
variables.  They may be used freely in any source file.  Variable
finish is initialized to the value 3.

Module Local Variables:

Variables that are declared as module local can be used only
in the module (source file) in which they are declared.
A module local variable declaration in a source file over-rides
any global variable declarations for that variable in that source
file only.  Module local variable declarations typically appear
at the top of the source file, although they may appear anywhere
outside any function or action statement.
Example:

	local x,y = "sss";
	local z

The variables x, y and z are declared local to the current module
(source file). Variable y is initialized to the value "sss".
The semi-colon is optional.

Note: assignments to local variables on the compiled program's command
line (using -v, for example) will not work because assignment on the
command line is restricted to global variables.  As a special case,
if there is only one AWK source file then undeclared variables are made
global automatically so that command line assignment to them will work.

Function Local Variables:

Function local variable declarations may be used in functions.
They must appear before any other statements in the function.
Example:

function ten_hellos()
{
    local i, msg = "hello";
    for (i = 1; i <= 10; i++) print msg
}

In the above example the variables i and msg are local to function
ten_hellos().  Variable msg is initialized to the value "hello".


Undeclared Variables:

Variables that are not declared are made module local by default,
so they are not automatically shared among all source files.
Alternatively, the "-g" option makes undeclared variables
global, so they are shared among all source files.
The "-s" option to the compiler prints warnings for undeclared
variables so that you can find them and declare them.


================= ADDITIONAL THOMPSON AWK FUNCTIONS =======================

    ord(str)
	Returns the ASCII sequence number corresponding to the first
	character of the string argument: str.
	is the inverse function of sprintf("%c",x), which returns
	the string character corresponding to ASCII sequence number x.
	This function is provided for completeness sake, but most uses
	can be re-written more elegantly using awk regular expressions.

    toupper(str)
    tolower(str)
	These functions return the string with characters converted
	to upper case or lower case.

    typeof(x)
	Returns a string corresponding to the type of x.
	The possible return values are:
		"int" for integer;
		"float" for floating point;
		"string" for string;
		"array" for any type of array;
		"regex" for a regular expression pattern;
		"fileid" for a file descriptor from the fopen() function;
		"null" for an uninitialized variable;
		"unknown" for anything else.

    kbhit(), getkey()
	Kbhit() returns non-zero only if a key is ready at the keyboard.
	Getkey() returns a key from the keyboard.  If none are ready it waits.
	If the key is a printing character, including tab, back-space,
	carriage-return, newline or formfeed, that character is returned.
	Otherwise getkey() returns the name of the key, for example "F1",
	"HOME" or "ESC".  If the key is an Alt-, Ctrl- or Shift- combination
	the key name is prefaced with "A-", "C-" or "S-", respectively.
	For example the key combination shift F1 returns "S-F1".

	Alternatively, if getkey is given an argument of 1 it returns
	the raw 16 bit integer corresponding to the IBM key-code
	of the key pressed.

	The behavior of getkey() and kbhit() is undefined for the keys
	Control-C, Control-S, Control-P, PrtSc and Control-PrtSc.

	These functions use the keyboard interrupt, so they only work on
	IBM compatible computers.  Non-IBM compatible computers are likely
	to crash if these functions are used.

    time(year,month,day,hour,minute,second)    or    time()
	Time() without arguments returns the current time as an integer
	with resolution in seconds.  Up to six arguments may be given
	to convert a specified date and time to an integer.  Not all
	arguments need be given; unspecified arguments default to the
	lowest value.  A warning message is printed if the year or month
	is out of range; no checks are made on the other arguments.
	The ranges of the optional arguments are:
		year:   1980 - 2100
		month:  1 - 12
		day:    1 - 31
		hour:   0 - 23
		minute: 0 - 59
		second: 0 - 59

    ctime(argument)
	Ctime() converts the argument returned by time() or filetime()
	to a string in the format: "Wed Jun 17 13:39:36 1987".
	If ctime() is invoked without arguments it returns the current time
	as a string.

    filetime(filename)
	Returns the modification time of the specified filename as an integer.

    filesize(filename)
	Returns the length in bytes of the specified filename, or -1
	if the file does not exist.

    filemode(filename)
	Returns a mode string representing the mode of the file or directory
	specified by the filename.  If the filename does not exist the empty
	string ("") is returned.  The letters in the mode string are
	assigned as follows:
	    "d" - the path is a directory;
	    "f" - the path is a file;
	    "c" - the path is a device driver ("con", "aux", "prn", etc.);
	    "r" - the file can be read (this is always true);
	    "w" - the file can be written;
	    "x" - the file is executable;
	    "h" - the file is a hidden file;
	    "s" - the file is a system file.

    and(x1,x2), or(x1,x2), xor(x1,x2), not(x1,x2),
    shiftl(x1,x2), shiftr(x1,x2)
	These are bitwise logical functions.  They coerce their arguments
	to 32 bit numbers and yield a 32 bit result number.  Shiftl does
	a left shift and shiftr does an arithmetic right shift.
	For example:

	    printf("0x%x",or(0x20,0x0f))           # prints 0x2f
	    printf("0x%X", not(1))                 # prints 0xFFFFFFFE

    system(program)
	The system() function runs the program by invoking the
	command interpreter specified by the COMSPEC environment
	variable.  The default command interpreter is command.com
	under MS-DOS, or cmd.exe under OS2.  To use an alternative
	command interpreter for the system() function you may change
	the COMSPEC environment variable.  For example:
    
	    ENVIRON["COMSPEC"] = "C:/usr/bin/sh.exe"
	    
	If the program specified by the COMSPEC variable can not be run
	there may be no warning message printed, but the system() function
	will return an error code of -1.
    
	If no error occurs the system() function returns the exit status
	of the command interpreter after executing the program specified
	by the system() function.  This is not particularly useful under
	MS-DOS because the exit status of command.com is always 0!
	There is also no way to detect if the program invoked by
	the system() function was abnormally terminated by a ^C interrupt,
	because command.com does not return it.  If you need reliable
	exit codes either use the spawn() function or use a better
	command interpreter like the Thompson Toolkit Shell.
    
	Warning: Microsoft has indicated that the system() function may not
	execute properly under MS-DOS version 2.  We have tested under
	MS-DOS version 2 and had no problems, but be warned.
	
	For more information see: ENVIRON array, SYSSWAP variable.

    spawn(program)  or  spawn(program,environment)
	This function runs the program and returns the exit status of
	the program, or -1 if the program could not be run. The program
	may not run if it can not be found, there is not enough memory,
	or if too many files are open.  If no pathname is specified
	then the program is searched for first in the current directory
	and then on the PATH.  If the optional second argument is
	specified it is an array containing the environment strings
	to be passed to the program, and defaults to the ENVIRON array.
	The spawn function differs from the system() function in that
	it does not start a copy of the DOS or OS2 command processor
	("command.com" or "cmd.exe") to run the program.
	It is therefore faster, uses less memory and returns
	the true exit status of the program.  Note that batch files
	and program names like "dir" are executed directly by command.com
	and so must be run using the system() function rather than spawn().
	OS2 presentation manager programs (these are programs that do
	graphics under OS2) can not be run with spawn: use system() instead.
	
	For more information see: ENVIRON array, SYSSWAP variable.

    getcwd(), chdir(directory)
	The getcwd() function returns the current directory name,
	including the disk drive specifier.  The chdir function changes
	the current disk drive and directory to those specified.
	Chdir() returns FALSE (0) if it fails, otherwise TRUE (non-zero).
	Chdir() operates differently from the DOS cd or chdir command in 
	that it changes both the disk drive and the directory path.
	For example:  chdir("/usr") will change to the /usr directory
	on the current drive, chdir("a:") will you change to the current
	directory on drive "a:", and chdir("a:\\") will change to the
	root directory on drive "a:".  Note that the backslash used
	as a directory separator must be doubled when appearing in
	a string in AWK.

    findfirst(pattern),  or  findfirst(pattern,flags)
    findnext()
	These functions are used to find filenames matching a given DOS
	filename pattern.  The pattern may include a directory prefix,
	for example "\\usr\\bin\\*.*".  Findfirst() returns the first
	filename that matches the pattern, if any, otherwise an
	empty string.  Findnext() returns the next matching filename
	until no more filenames match the pattern, then returns
	an empty string.  Only normal files are returned unless
	the optional flags argument is specified as one of the
	following values.  The values (except number 8 (volume id),
	which should be used alone) may be added together to return files
	matching any of the criteria.  Normal files are always included
	in the returned files even if flags is specified.
	    1  -  return read-only files;
	    2  -  return hidden files;
	    4  -  return system files;
	    8  -  return the volume id;
	    16 -  return sub-directories;
      

    fopen(filename,mode)
	Opens the specified filename for subsequent input/output
	operations of a type specified by the mode argument.
	The mode argument must start with one of the following:
	    "r"    File is opened for reading only;
	    "r+"   File is opened for reading and writing;
	    "w"    File is created for writing only; if the file previously
		   existed its former contents are lost;
	    "w+"   Like "w" but reading is also allowed;
	    "a"    File is opened for writing only; if the file did not exist
		   it is created, if the file did exist the current file
		   position is set at the end of the file so that writes
		   will occur at the end of the file.
	    "a+"   Like "a" but reading is also allowed.

	The file mode may also include a letter to specify "binary" or
	"text" mode.  If a file mode is specified then that mode is
	used for the file and the RAWMODE variable has no affect on this file.
	The following mode letters may be appended to the file mode:
	    "b"    The file is opened in binary mode: no translation
		   is performed on carriage-return line-feed sequences
		   and control-Z is not handled specially;
	    "t"    The file is opened in text mode;

	The following letters can also be appended to the file mode
	to specify that the file is to be opened with a specified
	file-sharing mode.  These sharing modes have no affect under DOS
	unless the "share.exe" program or some other file-sharing controller
	(like Microsoft Windows) is in use.  Once you have opened
	a file with a file sharing mode you can lock or unlock
	parts of the file; see the flock.awk example file to see how this
	is done.  The following are the supported file-sharing modes
	for both DOS and OS/2:
            "dr"   File is opened in DENY-READ sharing mode;
            "dw"   File is opened in DENY-WRITE sharing mode;
            "d+"   File is opened in DENY-READ-WRITE sharing mode;
            "dn"   File is opened DENY-NONE sharing mode;
                   (The deny-none mode is confusing: it actually denies
                   access to all other programs that do not specify
                   a compatible sharing mode.)

	Examples:
	To open file myfile.txt in the root directory of drive C: for reading:
	
	    fopen("C:\\myfile.txt","r")
	
	To open a data-base file for both reading and writing in binary mode
	with deny-none sharing mode:

	    fopen("\\dbase\\myfile.db","r+bdn")

       
	Fopen fails and returns 0 (FALSE) if the file could not be
	opened for any of the following reasons: file opened with
	mode "r" did not exist, the directory did not exist or was full,
	the file had a read-only attribute and the file mode specified
	writing, if a sharing violation occurred, if a network is in use
	and you have insufficient privileges to access the file or directory,
	or if all DOS file descriptors are in use.  In the last
	case AWK prints a warning message.

	If fopen succeeds it returns a non-zero file descriptor that can
	be used interchangeably with the filename for all subsequent file
	operations on the file.  However, you can just ignore the file
	descriptor and continue to use the file name for file operations.
	For example, the following are all legal:
     
	     pf = fopen("myfile","r")
	     getline < "myfile"
	     getline < pf
	     fread(10,"myfile")
	     fread(10,pf)
       
	It is especially advisable to use fopen() in the following cases:
	1)  If you want to specify an input/output mode other than
	the default ones, for example, if you want to both read and
	write to a file simultaneously, or if you want to specify a
	binary file and it is inconvenient to use RAWMODE.
	2)  If you want to start reading a file at a specific location:
	use fopen() to open the file, then fseek() to move to the
	specified location: fopen is needed because you can not use
	fseek() until you have opened the file.
     
	MORE DETAILS:

	When you use the getline or print/printf functions to read or
	write from a file you do not need to use fopen() to open
	the file first.  In this case files are opened automatically
	with the default modes as follows:

	     function        default mode   meaning
	     --------        ------------   -------
	     getline < file     "r"         file is open for reading only
	     print > file       "w"         file is open for writing only
	     print >> file      "a"         file is open for writing only,
					    data is appended to any existing
					    file.

	When you intermingle print>"file" and print>>"file" statements,
	the first print (or printf) statement for the "file" encountered
	at execution time determines the file mode.  Subsequent print
	(or printf) statements simply continue to write to the already
	opened file.

	An incompatible file I/O operation is one that attempts
	to read from a file opened for writing-only, or to write
	to a file opened for reading-only.  If the file was opened
	by fopen() then incompatible operations are disallowed.
	If the file was opened automatically then incompatible
	operations are allowed, but the file is automatically closed
	and re-opened with the new mode, and AWK prints a warning message.
 
    feof(filename)
	This returns 1 if the specified filename contains no more data
	to read, 0 if there is more data, or -1 if the file is not
	open for reading.

    fread(cnt,filename)
	Reads cnt bytes from filename and returns them as a string.
	If an error occurs an empty string is returned.  If the file
	is exhausted a string of less than cnt bytes in length will
	be returned.  A file descriptor returned by fopen() may be
	specified instead of filename.

    fwrite(str,filename)
	Writes the string argument: str to the filename.  The number
	of bytes written from str is returned.  If an error occurs
	0 is returned.  Note that the actual number of bytes
	written to the file will be greater than the return value
	because new-line ("\n") characters are translated to carriage-
	return new-line ("\r\n") sequences unless the RAWMODE
	variable specifies otherwise.  A file descriptor returned
	by fopen() may be specified instead of filename.

    ftell(filename)
	Returns the current location in the filename in bytes from
	the beginning of the file.  If the filename is not open -1
	is returned.  A file descriptor returned by fopen() may be
	specified instead of filename.

    fseek(filename,location), or fseek(filename,location,flag)
	After calling this function the next read or write operation
	on filename will occur at the specified location counted
	in bytes from the start of the file.  The file must be open
	before using this function.
	If the optional third argument (flag) is specified as 1,
	the location is measured as an offset from the current location.
	If the optional third argument (flag) is specified as 2,
	the location is measured as an offset from the end of the file.
	A file descriptor returned by fopen() may be specified instead
	of filename.

    fflush(filename)
	Any buffered output is written immediately to the specified filename.
	The fflush function should only be used on files that are being
	written to; if called on a file open for reading fflush causes a
	loss of all data currently buffered for input from that file.
	You rarely have to use this function because AWK automatically
	flushes before any fseek(), before a system() or spawn() call,
	before your program ends, and flushes after every write for
	files that are actually devices (for example, the console).
	A file descriptor returned by fopen() may be specified instead
	of the filename.
  
    fileno(filename)
	Returns the DOS file descriptor associated with filename,
	or -1 if the file is not open.  The DOS file descriptor is
	usually a number in the range 0 to 20.  This function is only
	useful when you need a file descriptor for a DOS interrupt.

	When AWK reads a file with the getline function it automatically
	closes the underlying DOS file descriptor when it no longer
	needs it, unless the file was opened by fopen().  So fileno()
	may return -1 even though the file appears open to your AWK program.
	To avoid this problem you can use fopen() on the file: after an
	fopen() call the underlying DOS file descriptor is never closed 
	until your program closes the file with the close() function.

    close(filename)
	[ Thompson AWK Enhancement ]
	A file descriptor returned by fopen() may be specified instead
	of the filename.  Hint: To skip processing of the remainder
	of the current input file and force AWK to go on to the
	next file on the command line, use close(FILENAME).


    interrupt(intno,AX,BX,CX,DX,SI,DI,DS,ES)
	USE THIS FUNCTION WITH CARE!
	YOU CAN CRASH YOUR COMPUTER OR LOSE FILES BY IMPROPER USE!
	If you are running under DOS this function performs interrupt
	number intno with the specified register values.
	If you are running under OS/2, this function does nothing.
	The register values are optional, but if given they must be
	specified in the order shown.  If you specify a variable
	for any register(s), the variable(s) receive the value
	returned by the interrupt in those register(s).
	The interrupt function returns the value of the carry
	flag after the interrupt.
	For example, to get the current date you could use
	MS-DOS interrupt 0x21 function 0x2A, which returns the
	year in CX and the month and day in DX as follows.
	The interrupt requires AH (high half of AX) to be 0x2A.
	The BX register is not used by the interrupt, but a value
	of 0 is specified as a place holder because we need CX and DX.
	(Documentation on interrupts is available from many sources,
	including "MS-DOS Functions" by Ray Duncan, Microsoft Press.)
      
		interrupt(0x21,0x2A00,0,year,moday)
      

    peek(address), poke(address,value)
	USE THESE FUNCTIONS WITH CARE!
	YOU CAN CRASH YOUR COMPUTER OR LOSE FILES BY IMPROPER USE!
	The peek() function gets and returns the byte at the specified
	address as an integer.  To convert the integer return value
	to a one character string use: sprintf("%c",peek(address)).
	The poke() function sets the byte at the specified address
	to the value, which must be an integer.  To poke the first
	character of a string use: poke(address,ord(string)).
	The address is specified as a 32 bit segment:offset, that is,
	the upper 16 bits of address are the segment and the lower
	16 bits are the offset.

    inp(port), inpw(port), outp(port,value), outpw(port,value)
	USE THESE FUNCTIONS WITH CARE!
	YOU CAN CRASH YOUR COMPUTER OR LOSE FILES BY IMPROPER USE!
	These functions perform input byte, input word, output byte,
	or output word to the specified I/O port with the specified
	integer value.  Under OS/2 these functions do nothing.

    getawkvar(name)
	Returns the value of the specified AWK variable.  Only variables
	that are declared global and that are not arrays can be specified.
	(An exception: if your program consists of a single source file then
	all variables are automatically considered global.)
	The following example prints "10":
      
	 global x
	 BEGIN {
	     x = 10
	     print getawkvar("x")
	 }

    setawkvar(name,value)    or   setawkvar(name,value,flag)
	Sets the value of the specified AWK variable to the specified value.
	If the optional third argument is 1 and the specified value is a
	string, then it is treated the same way AWK treats input fields,
	that is, the string is examined and treated as a number if it
	contains nothing but a number.

	Only variables that are declared global and that are not arrays
	can be set by setawkvar.  (An exception: if your program consists of
	a single source file then all variables are automatically considered
	global.)  The following example prints "17".
      
	 global x
	 BEGIN {
	     setawkvar("x",17)
	     print x
	 }

    argcount()
	This function returns the number of arguments that were passed
	to the function in which it is called.  The following
	example will print "2":

	    function foo(a,b,c) { print argcount() }

	    BEGIN { foo(x,y) }


    translate(string,searchlist,replacementlist)           or
    translate(string,searchlist,replacementlist, flags)
	This function translates string by replacing all occurrences
	of the characters specified in the searchlist with the
	corresponding characters in the replacmentlist.  The first
	character in the searchlist is translated to the first character
	in the replacement list, the second to the second, etc.  If the
	replacement list is empty, the characters in searchlist are
	just deleted.  If the replacement list is shorter than the
	searchlist, the last character is replicated as necessary,
	unless "d" is included in the optional flags argument.
	Both searchlist and replacement list can include ranges
	of the form: "a-z", which means all characters from "a" to "z",
	inclusive.  Character ranges can be reversed, for example,
	"a-d" means "abcd", and "d-a" means "dcba".  To include a
	dash character ("-") in the list it must be the first or
	last character in the list, or the "n" option must be specified.
	The optional flags argument is a string of characters
	that are options with meaning as follows:
	   "d":  Delete: If searchlist is longer than replacementlist
	         then characters in searchlist that do not have a
	         translation specified by replacementlist are deleted.
	         Normally these characters would be translated to the
	         last character of the replacement list.
	   "s":  Squeeze: Translations that would result in adjacent
	         identical characters from replacementlist in the output
	         string are replaced by (squeezed into) a single instance
	         of that character.  Note that only characters that
	         are translated are squeezed.  Characters that do
	         not appear in searchlist are left alone.
	   "c":  Complement: The searchlist used by translate is the
	         complement of the specified searchlist.  That is, the
	         searchlist used by translate is composed of of all
	         characters that do not appear in the searchlist.
	   "n":  This option suppresses interpretation of character ranges
	         in the searchlist and replacementlist, so for example,
	         "a-c" would mean "a-c" instead of "abc".
	Examples:
		# This returns str in upper case.
		translate(str,"a-z","A-Z")
		# This returns str after resetting the high bit
		# of each character.  (Useful for WordPerfect files.)
		translate(str,"\x80-\xff","\x0-\x7f")
		# This squeezes all white space characters to spaces.
		translate(str," \t\r\n"," ")
		# Use the squeeze option to change sequences of
		# white space characters to a single space:
		translate(str," \t\r\n"," ","s")
		# Use the complement option to change all characters
		# that are not alpha-numeric into spaces:
		translate(str,"a-zA-Z0-9"," ","c")
		# Delete all non-alphanumeric characters: (The "d" option
		# could be included but is not necessary in this case)
		translate(str,"a-zA-Z0-9","","c")


    strdup(string)    or    strdup(string,ncopies)
	If there is only one argument this function allocates
	and returns a new copy of string.  This is totally unnecessary
	in normal AWK, but is sometimes useful when interfacing
	to C routines to make sure that you have a new copy of string.
	If the "ncopies" argument is specified, strdup returns a new
	string containing that many adjacent copies of the string.
	Examples:
		strdup("a",1)    # Returns "a"
		strdup("ab",3)   # Returns "ababab"
	
    
    sleep(secs)
	This function delays execution for a specified time, which
	may be expressed as an integer or as a floating point number.
	Under DOS this function is implemented as a busy loop with
	accuracy only to within the accuracy of the IBM-PC clock,
	which is about 1/18 second.  Under OS2 this function yields
	control to the operating system so that other programs can run.
	The delay may be longer than that specified if the operating
	system does not return control to the AWK program promptly
	after the sleep time has expired.  Example:
	
	sleep(1.5)	# Waits 1 1/2 seconds
    

    regex(string)
	The string is compiled as a regular expression.  The resulting
	return value can be used as an argument to split, sub, gsub, match,
	or with the ~ or !~ operators.  You can use the value in the
	pattern part of a pattern-action statment using the ~ operator.
	For example:
	
	BEGIN {
	    x = regex("this is a pattern")
	    if (match(y,x)) print "it matched"   # Used in a match() function.
	    if (y ~ x) print "matched again"     # Used with ~ operator.
	}
	
	$0 ~ x { print "found" }          # Used in a pattern.
		
	Why would you use this function?  In AWK, regular expression matching
	occurs in two phases: first the regular expression is compiled
	into an internal state machine, then the string to be matched
	is examined using that state machine.  Compiling the state
	machines is slow; examining strings with them is lightning fast.
	The regex() function compiles the regular expression so
	that multiple compilations can be avoided.  Note that if
	you know what the regular expression is at compile time,
	you can specify the regular expression /like this/ which
	also tells AWK to compile the regular expression just once.
  
    length(x)
	[ Thompson AWK Extension ]
	If x is an array then length returns the number of elements in the
	array.  Like normal AWK, if x is a string then length returns
	the number of characters in the string.
	

    delete array
	[ Thompson AWK Extension ]
	In Thompson AWK you may delete an entire array using the delete
	statement.  In regular awk the delete statement can delete
	only a single element of an array.  It is faster to delete
	the entire array at once.

    substr(variable,startpos,length) = replacement_string
          or
    substr(variable,startpos) = replacement_string
	In Thompson AWK you can use the substr function on the left hand
	side of an assignment.  This replaces the substring of the specified
	string variable starting at "startpos" and continuing "length"
	characters with the replacement_string on the right hand side
	of the assignment.  The length of replacement string does
	not have to be the same as the substring that is being replaced.
	In fact, the length specified to substr can be 0 to indicate that
	the string is to be inserted at the specified position.
	If length is not specified, it defaults to replacing the entire
	string from startpos on.
	For example:
	
		x = "abcd"
		substr(x,2,2) = "xyz"    # Replaces "bc" with "xyz"
		print x                  # prints: axyzd
		substr(x,2,3) = ""       # Removes "xyz" from the string
		print x                  # prints: ad
		substr(x,1,0) = "hello"  # Inserts "hello" at the beginning.
		print x                  # prints: helload

	This is commonly used in conjunction with the match statement,
	which sets the RSTART and RLENGTH variables to the start
	and length of the substring that was matched.  For example:
	
	x = "abcd"
	if (match(x,"bc")) {
		substr(x,RSTART,RLENGTH) = "this replaces bc"
	}


================= ADDITIONAL THOMPSON AWK VARIABLES ===================


    ENVIRON array
	The environment strings are available in AWK in the builtin
	array variable: ENVIRON in the format ENVIRON["NAME"] = "value".
	For example, the minimum environment under MS-DOS would be:

	ENVIRON["COMSPEC"] = "C:\\command.com"
	ENVIRON["PATH"] = "C:\\dos;C:\\usr\\bin"

	Note that the names of the environment variables are case-
	sensitive; you must specify ENVIRON["COMSPEC"], not ENVIRON["comspec"].
	Remember also that if you need to use a backslash in a string
	in an AWK program you must use two backslashes because
	backslash is the string escape character.

	Changes to the environment made by modifying the ENVIRON array are
	passed to commands invoked by the AWK system() and spawn() functions.
	A maximum of 100 environment strings can be passed to a program.


    ARGV array
	[ Thompson AWK Extension ]
	Under DOS the ARGV[0] variable contains the full pathname of the
	executable program.  Under OS/2 or in a bound program (that runs
	under both DOS or OS2) ARGV[0] contains the actual path, if any,
	used to invoke the program, so if the program was found in the current
	directory the path may be missing. In the special case where the program
	was entered interactively ARGV[0] contains "awk".


    SYSSWAP
	This variable controls whether AWK programs will swap out
	their data space before executing another program using the
	system() or spawn() functions.  AWK swaps out its data space to
	make more room in memory for the executed program; without swapping
	most large AWK programs would not be able to run other programs
	at all.  By default the SYSSWAP variable is non-zero, causing
	swapping to occur.  Setting SYSSWAP=0 suppresses swapping.
	There are three possible reasons to do this:  1) If you do
	not know if the user of the compiled AWK program will have
	enough EMS/XMS memory or disk space to perform the swapping
	operation successfully;  2)  To run programs that must remain
	resident.  If a resident program is loaded on top of an AWK
	program that is swapped out, the AWK program immediately
	terminates with an indignant error message;  3) To run
	programs requiring too much environment space.  Before the
	AWK program swaps itself out it copies the environment for
	the program to its own stack space to save it.  However, there
	may be insufficient space on the stack to hold the environment.


    RECLEN
	This variable should not be used unless you are an EXPERT.
	This variable indicates the maximum input record length.
	The default value is 8000.  Input records that exceed this
	maximum length will be split apart.  Any left over characters
	are added to the next record.  AWK normally translates the
	"\r\n" sequence used by DOS to indicate end of line into the
	single character "\n".  If the input record is split exactly between
	the "\r" and the "\n" this automatic translation may not occur.
	Also note that RECLEN is the length of the input record AFTER
	translating "\r\n" to "\n", so if a record contains "\r\n" sequences
	its length as a string in AWK will be less than the length
	of the record as it appeared in the file.  This can be corrected
	by preventing such translation with the RAWMODE variable documented
	below.

	To read in fixed length records you can set the RECLEN variable to
	the fixed record length and the RS (record separator) variable
	to some character that will normally not appear in the record,
	for example RS = "\xff", or use the fread() function.


    RAWMODE
	This variable should not be used unless you are an EXPERT.
	This discussion applies only to normal AWK programs that are
	not combined AWK/C programs (programs created with the -xl,
	-xf or -xo options.)  See the awkprog.doc file for a discussion
	of how RAWMODE works in a combined AWK/C program.

	The RAMODE variable is an integer whose bottom three bits are
	binary flags that separately control AWK Control-Z processing
	and "\r\n" translation on input and output.  Normally RAWMODE = 0
	causing AWK to:  A) stop processing the file whenever
	a Control-Z is encountered;  B) translate "\r\n" to "\n" on input;
	C)  translate "\n" to "\r\n" on output.  RAWMODE may be set
	to other values as follows:

	If RAWMODE = 1, then AWK does not treat Control-Z specially.
	(This bit is ignored in a combined AWK/C program, which uses
	RAWMODE = 2 to control both input translation and Control-Z
	processing.)

	If RAWMODE = 2, then AWK does not translate "\r\n" to "\n"
	on input.

	If RAWMODE = 4, then AWK does not translate "\n" to "\r\n"
	on output.

	The values of RAWMODE can be combined by adding them together.
	For example if RAWMODE = 7, then all three flags are enabled
	and no special processing takes place on either input or output.

	You should be aware that if RAWMODE is enabled then funny results
	will ensue when you print to the terminal.  For example, if a
	line printed to the terminal ends only with "\n" instead of "\r\n",
	then the cursor is not moved to the left hand side of the screen.
	Also be aware that when printing to the terminal MS-DOS truncates
	lines containing a Control-Z character.

	Most editors can not edit any part of a file after any Control-Z
	character in the file.  If you allow a file to be created that
	contains Control-Z characters and try to edit it you may find
	that you can edit only the first part of the file.

	The implementation of the RAWMODE variable may change in future
	releases of Thompson AWK.

    stdin, stdout, stderr
	These pre-defined variables represent the standard-input,
	the standard-output, and the standard-error-output when
	your AWK program is run.  The standard-input and standard-
	output may be redirected on the AWK command line.
	(The standard-error-output can also be redirected but only
	if you use OS2 or an enhanced shell like the Thompson Toolkit.)

	For example, to print a message to the standard-error-output, use:

	    print "a message" > stderr

	To read 512 bytes from the standard-input you could use:
      
	    buf = fread(512,stdin)

	Do not confuse stdin with the keyboard.  Standard-input normally
	comes from the keyboard, but if the standard-input for the program
	is redirected, it comes from the specified file.
	If you want to read from the keyboard you can either use the getkey()
	function, or you can read from the DOS special filename "CON".
	This special DOS filename always stands for Console and
	can not be redirected.  For example, to read a line of input
	from the keyboard regardless of file input redirections, you can use:
      
	     getline msg < "CON"
      
	And to write to the terminal regardless of file output redirection
	you can use:
      
	     print "a message" > "CON"
      

    MEMAVAIL
	This variable shows the amount of regular DOS memory still available.
	This variable is of little use, because when regular memory fills
	up a compiled program simply starts using extended or expanded
	memory or disk space.  There is currently no easy way for a
	compiled AWK program to determine how much extended and/or expanded
	memory and/or disk space is left for the compiled program's use.
	When a compiled AWK program runs another external program using the
	system() or spawn() function it swaps out most of its data space,
	so the MEMAVAIL variable has no bearing on how much memory
	will be available for the external program.


    PROGLN
	For experts: this variable (actually a pseudo-variable) contains
	the line number in the AWK program file of the statement in which
	it appears.  It may be useful for debugging purposes.  For example,
	you can print this variable at various places in your program
	to indicate what line number is being executed.

  
    STACKAVAIL
	STACKAVAIL is the number of bytes of stack left.  It is
	provided for your interest only.


    XMSLIMIT,
    EMSLIMIT
	[ OS2 Version ]
	Programs compiled by our AWK Compiler for OS2 are normally dual-mode
	and can run under either DOS or OS2.  When run under DOS,
	they operate as described below.  When run under OS2 (that is,
	not in a DOS or Windows box) they use the virtual memory capabilities
	provided by OS2 instead.
	[ DOS Version ]
	Compiled AWK programs use memory in the following order:
	    Regular memory (typically below 640K) first;
	    Extended memory (up to XMSLIMIT);
	    Expanded memory (up to EMSLIMIT);
	    Disk temporary file.
	Extended memory is memory above 1 Megabyte when running under DOS.
	In order for an AWK program to use extended memory an extended
	memory manager such as Microsoft's HIMEM.SYS must be installed first.
	Expanded memory is a different type of memory and may be provided
	by an expanded memory manager in a 386-based computer or by an
	add-in memory card in any computer.
      
	Normally you do not need to worry about XMSLIMIT and EMSLIMIT:
	compiled AWK programs automatically check for the presence of
	extended or expanded memory and use it if available.
	The default values of XMSLIMIT and EMSLIMIT allow compiled
	AWK programs to use all available extended and/or expanded memory.
      
	However, if your AWK program needs to call another program that
	needs extended or expanded memory, you may set XMSLIMIT to specify
	the maximum number of Kbytes of extended memory that the compiled
	AWK program may use, and/or EMSLIMIT to specify the maximum number
	of Kbytes of expanded memory that the AWK program may use.
	For example, if XMSLIMIT=0 then no extended memory will be used,
	and the AWK program will not even check for the existence
	of extended memory.  If XMSLIMIT=320 then a maximum of 320
	Kbytes of extended memory will be used.


    SORTTYPE
	SORTTYPE controls the automatic sorting of arrays
	in the "for (i in array)" construct.  The possible
	values you may assign to SORTTYPE are:
		SORTTYPE=0    no automatic sorting;
		SORTTYPE=1    alphanumeric sorting (default value);
		SORTTYPE=2    alpha sorting (ASCII collating sequence).

	If SORTTYPE=0 the elements of the array will be accessed
	in a semi-random order.


    ERRNO
	This variable is of little value, but is included for use by
	experts.  ERRNO contains the DOS error code after a low-level
	DOS function returns an error.  This variable is often set
	by DOS whether an error occurs or not, so its value is only
	valid after an error occurs, for example, when a file can not
	be opened.  For more information on DOS errors see a DOS manual.

    TMPDIR
	This variable specifies the directory where the AWK program
	will create temporary files.  It is initialized to the value
	of the TMP environment variable, if any.  You will be able
	to use more memory in AWK if you set this variable to a
	directory on a disk that has more disk free space.  See
	the discussion of "virtual memory" below.

    WARNINGS variable:
	If set to 0, your compiled AWK program will not print warning
	messages.  The default value is 1 to print warning messages.
	You can also set this variable to 0 and suppress warning
	messages by specifying the -w flag on the command line of
	your compiled program.

    OSMODE
	The value of this variable is 0 if running under DOS, or 1
	if running under OS/2.

    VERSION
	This contains the current AWK version as a field string, for
	example, "2.00".


================= ADDITIONAL THOMPSON AWK FEATURES ===================

    Binary Files:
	Thompson AWK can read, write and process binary files,
	including files containing the character 0, which is not
	treated specially by AWK and can appear in any string
	or regular expression just like any other character.
	Normally AWK treats newline carriage-return sequences and
	the Control-Z character specially, but this can be controlled
	by setting the RAWMODE variable, or by using the fopen() function
	and specifying a binary file mode.  (See documentation above.)

    Virtual Memory:
	Compiled AWK programs employ a virtual memory methodology to store
	arrays that are too large to fit in normal memory.  If the program
	is running under DOS and runs out of regular memory it will then
	use up to 12 Megabytes of extended memory, expanded memory, and/or
	disk space, allocated in that order.  If the program is running
	under OS2 it can use up to 32 Mbytes of virtual memory supplied
	by the OS2 operating system.  There is significant overhead
	in the way arrays are stored inside AWK, so the actual amount
	of information that can be stored is less.
    
    Automatic Sorting:
	Thompson AWK automatically sorts arrays by the array index, depending
	on the value of the SORTTYPE variable documented above.  In the
	default case indicies that are integers, or contain embedded
	integers, are sorted numerically; otherwise the indicies are sorted
	as strings in ASCII collating sequence.  This builtin sorting
	mechanism may be used in place of the "sort" command mentioned so
	often in the AWK book.
    
	Note that this feature allows you to create AWK arrays with
	integer indicies, then use a "for" statement to access the elements
	of the array in numeric order, just as you would expect.  For example,
	the following program will print "first", "second", and "third",
	in that order.
    
	    x[1] = "first"
	    x[3] = "third"
	    x[2] = "second"
	    for (i in x) print x[i]
    
	Arrays that are too big to fit into memory cause disk thrashing
	when they are sorted.  In these cases AWK repeatedly reads
	and writes the data in the array to the disk in order to sort it.
	Setting SORTTYPE=0 greatly increases the execution speed of programs
	whose array size exceeds memory size.
    

    Multi-Dimensional Arrays:
	Thompson AWK supports true multi-dimensional arrays.  Multi-dimensional
	arrays are written with multiple brackets such as: x[0][1].
	To print all the elements of such an array you could use a
	program such as:
    
	    for (i in x) {
		for (j in x[i]) {
		    print x[i][j]
		}
	    }
    
	If an array variable is assigned to another variable,
	the result is an additional reference to the same array.
	The following example will print "10":
    
	    x[1] = 10;  y = x;  print y[1]
    

    Printf Flags:
	Thompson AWK provides additional functionality in printf and sprintf
	format specifications.  See the AWK manual page 56-57.
	The Thompson AWK additions are:
    
	    %m  - money format: negative numbers appear in parenthesis,
		  and the default precision is two decimal places.
		  Positive numbers are preceded and followed by a space
		  so that positive and negative numbers printed in a column
		  can easily be lined up on the decimal point simply by
		  specifying a field width, for example %10m.
	    %b  - binary number format, 32 bits maximum.
	    %zf - like %f but suppress trailing insignificant zeros.
	    %ze - like %e but suppress trailing insignificant zeros.
	    %X  - like %x but uses capital letters "A" through "F".
	    %E  - like %e but print an uppercase "E" instead of "e".
	    %G  - like %g but print an uppercase "E" instead of "e".
	    %g  - the precision, if specified, is the number of digits
		  to the left of the decimal point in "%e" format.
		  That is, the precision specifies the number of significant
		  digits (plus one) to be printed.  If the number can be
		  printed unambiguously in "%f" format that format is used,
		  however, the same number of significant digits will be printed
		  in either "%e" or "%f" format, with insignificant trailing
		  zeros suppressed.  (This is unlike the C language.)
    
	The following flag characters may appear in a format specification
	following the percent character and before any letter characters:
    
	    +   - Print a plus sign if the number is positive.
	    ' '   (a space character) - Print a space preceding the number
		  if it is positive;  this is used to help line up numbers
		  in columns.
	    ^   - Use engineering notation for %e or %g specifications.
	    #   - Always print a decimal point for %e, %f, or %g specifications;
		  normally the decimal point is suppressed if there are no
		  zeros following it.
    

    Hex Numbers
	Thompson AWK recognizes hexadecimal numbers prefixed with "0x",
	for example 15 may be written as 0xf.  Hexadecimal numbers
	may appear in the AWK program source files or input files wherever
	a number is expected.  Hex numbers are stored internally
	as 32 bit numbers.
    
	Strings and regular expressions may also contain hexadecimal
	escape sequences in the form "\xdd" where d is any hexadecimal
	digit.  For example the string "\xff" is a single character string
	containing the character 255.
    

    AWK -w flag:
	AWK prints warning messages for questionable programs.
	The -w flag can be used to suppress all warning messages.
    
	The warning message: "= used where == expected" is printed
	when an assignment (=) appears in an "if", "while", or "for"
	statement boolean expression.  The message can be prevented by
	enclosing the assignment in an additional pair of parentheses.
    
	The warning message: "Comparison of string with number" is printed
	when >, >=, <, or <= is used to compare a string to a number,
	or for the expressions: (0 == "") or (0 != "").  The message
	is printed because these types of comparisons usually indicate
	an error in the AWK program.  The message can be prevented by
	coercing both the arguments of the comparison to the appropriate type,
	either number or string, by concatenating "" or adding 0.
	This is discussed on pages 44,45 of "The AWK Programming Language."
    

    Other Thompson AWK Features:
	Thompson AWK allows multiple BEGIN or END patterns.
	The actions associated with multiple BEGIN or END patterns
	are executed in the order they appear in the AWK program source file.
	If there are multiple AWK program source files they are executed
	in the order the filenames are specified on the command line.
    

========================== OTHER DETAILS ===============================


This section describes additional details of AWK and is
provided for EXPERTS; others can safely ignore it.

    Smart Linking:

	The AWK Compiler uses a linking strategy completely different from
	C, PASCAL, or other compilers.  All source files are compiled
	into a single compiled output file which contains a single
	symbol table that contains all the symbols for the entire program.
	A normal compiler, like a C Compiler, needs to use header files
	to declare all the global variables and often the functions
	that are shared between different source files.
	The single symbol table used by AWK means that global variables
	and functions in AWK do NOT need to be declared in every source
	file, but can be defined in one or more source files where ever
	it is convenient for the user.  The single symbol table can also
	save a great amount of time during compilation because AWK
	does not have to read and parse a bunch of header files each
	time it compiles a source file.
       
    AWK Numbers:

	AWK numbers have 15 significant decimal digits and may fall
	in the range 1e-307 to 1e308.  Division by zero is permitted
	but produces a warning message and an undefined result.
	The undefined result may result in a further fatal error
	message if used in another numeric operation.
    
	AWK keeps numbers either as 32 bit integers or as double
	precision (64 bit) floating point numbers, which ever is
	appropriate.  Integers are used wherever possible because integer
	computations are much faster than floating point.  When an
	integer computation overflows the result is automatically promoted
	to floating point.
    
	When floating point numbers are compared in other versions of AWK
	they may appear "not-equal" due to floating point round-off error
	even though they should be "equal".  Thompson AWK solves this problem
	by internally preserving the precision of real numbers, where
	the precision is defined as the number of decimal digits to the
	right of the decimal point.  The precision is preserved across
	addition, subtraction, multiplication, and division by a constant
	power of 2 or 10.  When two numbers are compared only the
	significant digits participate in the comparison.  Also,
	numbers printed by the "print" command that are zero within their
	precision are printed as true zero rather than as teeny tiny numbers.
    
	AWK automatically uses a floating point co-processor if one is
	present in the computer; otherwise floating point operations are
	performed by software subroutines.

    AWK Regular Expressions:

	Thompson AWK compiles regular expressions into finite state
	machines that make exactly one transition on each input character.
	These state machines are extremely fast, so do not be afraid
	to use them instead of string comparisons.  Regular expressions
	specified as /expression/ are compiled once when the awk program
	is read in.  Regular expressions specified as "expression" may
	be re-compiled each time they are specified, although Thompson AWK
	remembers one previous "expression" to prevent unnecessary compiling.
	The regular expression compiler is relatively slow, so use
	/expression/ instead of "expression" where possible.
	The regex() function can be used to compile regular expressions
	that will be used many times, this can result in a significant
	program speed-up.  The regex() function is documented above.
    
    Thompson AWK Limits:

	Maximum number of fields is 512.
	Out of range field references ($n where n < 0 or n > 512)
	all refer to field $512.
    
	Maximum record length is 8000 bytes.  A shorter limit for
	input records may be specified by the RECLEN variable.
	Records that are too long generate a warning message and
	are split.
    
	Maximum string length from string concatenation or sprintf function
	is 8000 bytes.  Longer strings are truncated.
    
	Maximum expression nesting is 20 nested parentheses.
       
	There is no fixed limit on the length of arrays, but a practical
	limit does exist on the maximum size of an array that can be
	sorted: when a single array no longer fits in memory
	your program will slow down drastically when that array is sorted.
	You can use SORTTYPE=0 to prevent sorting huge arrays.
	The SORTTYPE variable is described in the documentation above.
    
======================== AWK BOOK CHANGES ==============================

1)  To print directly to the terminal the AWK book uses:

	    print "message" | "cat 1>&2"

    This does not work under MS-DOS, so use the following instead:

	    print "message" > "CON"


2)  To obtain the system date the AWK book uses the UNIX "date" command
    as follows:

	    "date" | getline date

    This does not work under MS-DOS because the MS-DOS "date" command
    functions differently than the UNIX date command.  Thompson
    AWK has a built-in function to return the current date that
    can be used as follows:

	    date = ctime();

3)  The parser program on page 149 will not parse the example program
    on page 147 if the blank lines contain tabs or spaces.  To fix it
    add an else clause near the top of function advance() as follows:

	if (getline line == 0)
	    return tok = "(eof)"
	else sub(/^[ \t]+/,"",line)

======================== AWK COMPATIBILITY ==============================

Our AWK is 100% compatible with "The AWK Programming Language" book.
Unfortunately, this does not guarantee compatibility with all AWKs.
The following lists problem areas to look for:

Moving Thompson AWK programs to UNIX:
    You should have few problems transporting your AWK programs to UNIX
    as long as you do not use any of our extensions to AWK, and as
    long as you avoid AWK Incompatibility Problems listed below.
    There are a very few versions of AWK on UNIX systems that implement
    backslashes in strings improperly; in this case use the Thompson
    AWK -eb option.
    
    Note that many versions of UNIX have two different versions of awk:
    an old one called "awk" and a new one called "nawk".  The old
    version of awk is ancient, and does not implement functions or many
    other newer features of awk.  Some older versions of UNIX do
    not have "nawk", and have only the ancient "awk" available,
    in which case you need to acquire "nawk".  So if you have problems
    under UNIX, make sure you are using the lastest version.

Moving UNIX AWK programs to Thompson AWK:
    Usually there is no problem.  Some AWK programs developed on UNIX
    make system calls to other UNIX utilities using the AWK system()
    function.  These utilities are not implemented in DOS, so these
    system calls need to be changed.  In most cases Thompson AWK has
    a built-in function that provides the same functionality without
    having to resort to a system call.  Alternatively, you may wish
    to purchase the Thompson Toolkit, which includes many UNIX compatible
    utilities and makes it easier to port these AWK programs to DOS.

Common AWK Incompatibility Examples:

    1)  Backslashes in Strings:
    Unfortunately, there are a few UNIX versions of AWK that
    interpret backslashes in strings incorrectly.  If this is the
    case, use the Thompson AWK -eb option, which makes Thompson AWK
    treat backslashes in strings in the same incompatible manner.
   
    2)  Function Evaluation:
    Thompson AWK evaluates function arguments from right to left.
    While the order of evaluation is unspecified in the AWK book,
    most other versions of AWK evaluate function arguments from
    left to right.  Thompson AWK uses right to left evaluation
    because this makes it easier to link to C libraries and call
    C functions directly from AWK, because C also uses right to
    left evaluation.

    3)  Assignment:
    Thompson AWK evaluates the right-hand side of the assignment first,
    which is C compatible, while some other AWKs evaluate the left-hand
    side of an assignment first.  For example:

	x = 1
	line[x] = line[x++]

    In Thompson AWK results in:

	line[2] = line[1]

    But in some other AWKs the left hand side (line[x]) is evaluated
    first resulting in:

	line[1] = line[1]
